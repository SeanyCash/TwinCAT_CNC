<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_SpindleFunctions" Id="{d33eb993-f1a5-484e-9d4d-ae7861108719}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SpindleFunctions IMPLEMENTS I_HMI;

// Spindle VFD control for Invertek Optidrive E3 (240V single phase input, 240V three phase output, 2.2KW) and GMT 400hz 2.2kw 3 HP Spindle using Modbus RTU
VAR_INPUT
    
nSpindleSpeedFromNC     : UINT;
bManualSpindleOverride  : BOOL;

END_VAR


VAR
	
fbModbusRTUComms			: FB_ModbusRTU_SerialComms;
    
 fbModbusMasterEL           : ModbusRtuMasterV2_KL6x22B;
 fbSpeedRefScale            : FB_CTRL_SCALE;
 fbSpeedRefScaleforHMI      : FB_CTRL_SCALE;
 fbMessage		    		: FB_TcMessage;
 stSpeedRefScaleParams            : ST_CTRL_SCALE_PARAMS;
 stSpeedRefScaleParamsforHMI      : ST_CTRL_SCALE_PARAMS;
 fScaledSpindleSpeedRef    : LREAL;
 nModbusReadBlk1    : ARRAY [1..46] OF INT;
 nModbusReadBlk2    : ARRAY [129..188] OF INT;
 // Need to put into a modbus DUT
 nModbusID          : BYTE :=1;
 nModbusReadQty     : WORD :=24;
 nModbusReadAddr    : WORD;
 bReadExecute       : BOOL;
 bDiagExecute       : BOOL;
 eReadErrorID       : MODBUS_ERRORS;
 nCbRead            : UINT;
 bReadBusy          : BOOL;
 bReadError         : BOOL;
 bWriteBusy         : BOOL;
 bWriteError        : BOOL;
 nCbWrite           : UINT;
 bResetSerialComm   : BOOL;
 
 bWriteDriveCommand             : BOOL;
 bWriteDriveSetpoint            : BOOL;
 bWriteAccel_Decel              : BOOL;
 nModbusWriteDriveCommand       : WORD;
 nModbusWriteDriveSetpoint      : INT;
 nModbusWriteDriveAccel_Decel   : UINT;
 trigWriteBusy					: F_TRIG; // When Write Busy goes TRUE to FALSE the Modbus action has completed
 trigReadBusy					: F_TRIG; // When Read Busy goes TRUE to FALSE the Modbus action has completed
 
 eVFDErrors         : E_VFDErrors;
 stSpindleStatus	: ST_SpindleStatus;
 stSpindleParams    : ST_SpindleParameters;
 stSpindleControl   : ST_SpindleControl;

// Sequence Enumerations
 eReadVFDParamsSeq      :(INIT_FIRST,READ_FIRST_BLOCK,INIT_SECOND,READ_SECOND_BLOCK,FINISH);
 nEnableSpindleSeq      :INT;
 eSetSpindleSpeedSeq    :(START,SET_ACCEL,SET_SPEED,FINISH_SPEED,START_ENABLE,ENABLE_DRIVE,RESET_DRIVE,FINISH_ENABLE,SPINDLE_ACTIVE);
 eCoastStop             :(INIT_STOP,ENABLE_STOP,WAIT_FOR_STOPPED,DISABLE_DRIVE,FINISH_STOP);

bTestEnable: BOOL;
bTestSetSpeed: BOOL;
bTestAccel  : BOOL;
nManualSpindleSetpoint  : UINT;
nSpindleSetpoint        : UINT;

END_VAR

VAR_OUTPUT
    bSpindleAtRequestedSpeed    : BOOL;
END_VAR


]]></Declaration>
    <Implementation>
      <ST><![CDATA[M_ReadParameters();
M_InputMapping();
M_OutputMapping();
M_DriveErrors();
M_HMI_In();
M_HMI_Out();
M_SpindleTesting();

(*
                                       
fbModbusRTUComms(
	nModbusStationAddress:= , 
	bReadExecute:= , 
	nReadQuantity:= , 
	nModbusReadDataAddress:= , 
	nModbusReadData:= , 
	bWriteExecute:= , 
	nWriteQuantity:= , 
	nModbusWriteDataAddress:= , 
	nModbusWriteData:= , 
	bReadComplete=> , 
	bReadFailed=> , 
	bWriteComplete=> , 
	bWriteFailed=> );	*)]]></ST>
    </Implementation>
    <Method Name="M_ActiveSpeedChange" Id="{8c91d8ac-e153-43a1-8a22-2e9bee5bdf48}">
      <Declaration><![CDATA[METHOD M_ActiveSpeedChange : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stSpindleStatus.nSpeedRefSetpoint <> nModbusWriteDriveSetpoint THEN
    fbModbusMasterEL.WriteSingleRegister(   
                                                  UnitID:=1,
                                                  Quantity:=1,
                                                  MBAddr:=1,
                                                  cbLength:=SIZEOF(nModbusWriteDriveSetpoint),
                                                  pMemoryAddr:=ADR(nModbusWriteDriveSetpoint),
                                                  Execute:=TRUE,
                                                  Timeout:=T#400MS,
                                                  Busy => bWriteBusy );      
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CoastStop" Id="{f02bd68b-a8e2-4168-ba64-5310fb0ed017}">
      <Declaration><![CDATA[METHOD M_CoastStop : BOOL
VAR_INPUT
    bExecute    : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eCoastStop OF


 INIT_STOP:

    M_CoastStop := FALSE;
    stSpindleControl.bCoastStopRequest  := FALSE;
    IF NOT stSpindleControl.bCoastStopRequest THEN
        eCoastStop:=ENABLE_STOP;
	END_IF 
    
ENABLE_STOP:

    stSpindleControl.bCoastStopRequest := TRUE;
    stSpindleControl.bRunEnable := FALSE;
    fbModbusMasterEL.WriteSingleRegister(   
                                          UnitID:=1,
                                          Quantity:=1,
                                          MBAddr:=0,
                                          cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                          pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                          Execute:=stSpindleControl.bCoastStopRequest,
                                          Timeout:=T#400MS,
										  Busy => bWriteBusy );
	 trigWriteBusy(CLK := bWriteBusy); 
     IF trigWriteBusy.Q THEN
        	eCoastStop:=WAIT_FOR_STOPPED;
        	stSpindleControl.bCoastStopRequest := FALSE;
     END_IF
     
WAIT_FOR_STOPPED:
    IF stSpindleStatus.nOutputFreq = 0 THEN 
        eCoastStop:=DISABLE_DRIVE; 
     END_IF
    
 
DISABLE_DRIVE:

    stSpindleControl.bRunEnable := FALSE;
    stSpindleControl.bCoastStopRequest := FALSE; 
    fbModbusMasterEL.WriteSingleRegister(   
                                          UnitID:=1,
                                          Quantity:=1,
                                          MBAddr:=0,
                                          cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                          pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                          Execute:= NOT stSpindleControl.bRunEnable,
                                          Timeout:=T#400MS,
										  Busy => bWriteBusy);
	 trigWriteBusy(CLK := bWriteBusy); 
     IF trigWriteBusy.Q THEN
     	eCoastStop:=FINISH_STOP;  
     END_IF 

FINISH_STOP:
	IF (stSpindleStatus.nOutputFreq = 0) AND stSpindleControl.bRunEnable = FALSE THEN
    	stSpindleControl.bCoastStopRequest := FALSE;
    	fbMessage.CreateEx(TC_Events.CNC_Events.Spindle_Stopped,0); 
    	fbMessage.Send(0);
    	eCoastStop :=INIT_STOP;
    	M_CoastStop:=TRUE;
    	bExecute := FALSE;
	END_IF
   
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DriveErrors" Id="{5214dc49-55b0-4763-8ae7-946b59ed4930}">
      <Declaration><![CDATA[METHOD M_DriveErrors : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[eVFDErrors:= stSpindleStatus.nErrorCode;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Enable" Id="{00000b6e-cbd2-4a72-a802-b97127827ff0}">
      <Declaration><![CDATA[METHOD M_Enable : BOOL
VAR_INPUT
    bExecute    : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nEnableSpindleSeq OF
    
0:
    M_Enable:=FALSE;
    stSpindleControl.bRunEnable := FALSE;
    stSpindleControl.bResetReq  := FALSE;
    IF NOT stSpindleControl.bRunEnable AND NOT stSpindleControl.bResetReq AND bExecute THEN
        nEnableSpindleSeq:=5;
	END_IF 
    
5:

    stSpindleControl.bRunEnable := TRUE;

    fbModbusMasterEL.WriteSingleRegister(   
                                                                UnitID:=1,
                                                                Quantity:=1,
                                                                MBAddr:=1,
                                                                cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                                                pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                                                Execute:=TRUE,
                                                                Timeout:=T#400MS, ); 
     IF stSpindleStatus.bDriveEnabled AND stSpindleStatus.bDriveReady THEN 
        nEnableSpindleSeq:=20;
     ELSE
        nEnableSpindleSeq:=10;   
     END_IF 
                                                    
10:
    
    stSpindleControl.bRunEnable:= TRUE;
    stSpindleControl.bResetReq := TRUE;

    fbModbusMasterEL.WriteSingleRegister(   
                                                                UnitID:=1,
                                                                Quantity:=1,
                                                                MBAddr:=1,
                                                                cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                                                pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                                                Execute:=TRUE,
                                                                Timeout:=T#400MS, );
     IF stSpindleStatus.bDriveEnabled AND stSpindleStatus.bDriveReady THEN 
          nEnableSpindleSeq:=FINISH_ENABLE;
     END_IF 

20:

   // stSpindleControl.bRunEnable := FALSE;
    stSpindleControl.bResetReq  := FALSE;
    fbMessage.CreateEx(TC_Events.CNC_Events.Spindle_Active,0); 
    fbMessage.Send(0);
    nEnableSpindleSeq :=0;
    M_Enable:=TRUE;
    bExecute := FALSE;

END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_FastStop" Id="{de81cf2d-b911-460a-8df3-f1e95bcc53de}">
      <Declaration><![CDATA[METHOD M_FastStop : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_HMI_In" Id="{7023150e-5dba-40bd-b6bf-f2224d2f965b}">
      <Declaration><![CDATA[METHOD M_HMI_In : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Trigger a state machine reset in the Read Parameters block to reset spindle comms
bResetSerialComm:= stHMI_In.bResetSerialComm;
bManualSpindleOverride := stHMI_In.bManualSpindleOverride;
nManualSpindleSetpoint := stHMI_In.nManualSpindleSetpoint;

(*IF stHMI_In.bSpindleSpeedExecute AND stHMI_In.bManualSpindleOverride THEN     
     bSpindleSetManually := M_SetSpeed();
     IF bSpindleSetManually THEN
         stHMI_In.bSpindleSpeedExecute:=FALSE;
	 END_IF
END_IF*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_HMI_Out" Id="{7a175b83-8eaa-4aad-b855-25562de10eb8}">
      <Declaration><![CDATA[
METHOD M_HMI_Out : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map VFD status information to HMI struct
stHMI_Out.nSpeedRefSetpoint	    := stSpindleStatus.nSpeedRefSetpoint;	  
stHMI_Out.nRampControlTime      := stSpindleStatus.nRampControlTime;    
stHMI_Out.sErrorCode		    := TO_STRING(eVFDErrors);	 
stHMI_Out.bDriveRunning         := stSpindleStatus.bDriveRunning; 
stHMI_Out.bDriveFault           := stSpindleStatus.bDriveFault;   
stHMI_Out.bStandbyMode          := stSpindleStatus.bStandbyMode;  
stHMI_Out.bDriveReady           := stSpindleStatus.bDriveReady;   
stHMI_Out.nOutputFreq		    := stSpindleStatus.nOutputFreq;	 
stHMI_Out.nMotorCurrent		    := stSpindleStatus.nMotorCurrent;
stHMI_Out.nMotorTorque          := stSpindleStatus.nMotorTorque; 
stHMI_Out.nMotorPower           := stSpindleStatus.nMotorPower;  
stHMI_Out.bDigitalInput1  	    := stSpindleStatus.nDigitalInputSts.0;
stHMI_Out.bDigitalInput2  	    := stSpindleStatus.nDigitalInputSts.1;
stHMI_Out.bDigitalInput3  	    := stSpindleStatus.nDigitalInputSts.2;    
stHMI_Out.bDigitalInput4  	    := stSpindleStatus.nDigitalInputSts.3;
stHMI_Out.bDriveEnabled         := stSpindleStatus.bDriveEnabled;       
stHMI_Out.nDCBusVoltage		    := stSpindleStatus.nDCBusVoltage;		     
stHMI_Out.nDrivePowerStageTemp  := stSpindleStatus.nDrivePowerStageTemp;
stHMI_Out.bRelayOutputStatus    := stSpindleStatus.nRelayOutputStatus.0;   
stHMI_Out.nKWHourMeter          := stSpindleStatus.nKWHourMeter;  
stHMI_Out.nRuntimeHours         := stSpindleStatus.nRuntimeHours;
stHMI_Out.nRuntimeMinutes       := stSpindleStatus.nRuntimeMinutes;
stHMI_Out.nInternalDriveTemp    := stSpindleStatus.nInternalDriveTemp;  
stHMI_Out.nOutputVoltage        := stSpindleStatus.nOutputVoltage;
// Map VFD Parameter information to HMI struct
stHMI_Out.nMaxSpeedLimit		:= stSpindleParams.nMaxSpeedLimit;
stHMI_Out.nMinSpeedLimit	    := stSpindleParams.nMinSpeedLimit;
stHMI_Out.fAccelRampTime		:= UINT_TO_REAL(stSpindleParams.nAccelRampTime)/100;
stHMI_Out.nDecelRampTime		:= stSpindleParams.nDecelRampTime;
stHMI_Out.nStopMode			    := stSpindleParams.nStopMode;
stHMI_Out.nMotorRatedVoltage	:= stSpindleParams.nMotorRatedVoltage;
stHMI_Out.nMotorRatedCurrent    := stSpindleParams.nMotorRatedCurrent;
stHMI_Out.nMotorRatedFrequency  := stSpindleParams.nMotorRatedFrequency;
stHMI_Out.nMotorRatedSpeed      := stSpindleParams.nMotorRatedSpeed;
stHMI_Out.nApplicationMode      := stSpindleParams.nApplicationMode;
stHMI_Out.nRelayOutputFunction  := stSpindleParams.nRelayOutputFunction;
stHMI_Out.nUserPGain            := stSpindleParams.nUserPGain;
stHMI_Out.nUserIConstant        := stSpindleParams.nUserIConstant;
stHMI_Out.nMotorControlMode     := stSpindleParams.nMotorControlMode;
stHMI_Out.nMaximumCurrentLimit  := stSpindleParams.nMaximumCurrentLimit;

//// Map Modbus Comms information to HMI struct

stHMI_Out.sReadErrorID := TO_STRING(eReadErrorID);
stHMI_Out.bSpindleAtRequestedSpeed := bSpindleAtRequestedSpeed;

stSpeedRefScaleParamsforHMI.fInMax:= 4000.0 ;
stSpeedRefScaleParamsforHMI.fInMin:=  1333.0;
stSpeedRefScaleParamsforHMI.fOutMax:=  24000.0;
stSpeedRefScaleParamsforHMI.fOutMin:=  8000.0;
stSpeedRefScaleParamsforHMI.tCtrlCycleTime:= T#2MS  ;
stSpeedRefScaleParamsforHMI.tTaskCycleTime:=  T#2MS ;

// Scale Spindle Speed Setpoint From RPM to Hz


fbSpeedRefScaleforHMI(
                fIn:=stSpindleStatus.nSpeedRefSetpoint,
                fOut=>stHMI_Out.fScaledSpindleSpeedRef,
                eErrorId=>,
                bError=>,
                stParams:=stSpeedRefScaleParamsforHMI,
                                                    );

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InitalizeParameters" Id="{02772613-62d0-43d8-a964-5b84e2c9be3d}">
      <Declaration><![CDATA[METHOD M_InitalizeParameters : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InputMapping" Id="{83d865f8-d7ae-49d7-a6f4-fcb7ec40a615}">
      <Declaration><![CDATA[METHOD M_InputMapping : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map Spindle Status
stSpindleStatus.nControlWord        := INT_TO_WORD(nModbusReadBlk1[1]);	   
stSpindleStatus.nSpeedRefSetpoint	:= nModbusReadBlk1[2];
stSpindleStatus.nRampControlTime    := INT_TO_UINT(nModbusReadBlk1[4]);
stSpindleStatus.bDriveRunning       := nModbusReadBlk1[6].0;
stSpindleStatus.bDriveFault         := nModbusReadBlk1[6].1;
stSpindleStatus.bStandbyMode        := nModbusReadBlk1[6].5;
stSpindleStatus.bDriveReady         := nModbusReadBlk1[6].6;                                  
stSpindleStatus.nErrorCode			:= INT_TO_BYTE(SHR(nModbusReadBlk1[6],8)); 
stSpindleStatus.nOutputFreq			:= nModbusReadBlk1[7];	
stSpindleStatus.nMotorCurrent		:= INT_TO_UINT(nModbusReadBlk1[8]);  
stSpindleStatus.nMotorTorque        := nModbusReadBlk1[9];  
stSpindleStatus.nMotorPower         := INT_TO_UINT(nModbusReadBlk1[10]);  
stSpindleStatus.nDigitalInputSts	:= INT_TO_WORD(nModbusReadBlk1[11]);
stSpindleStatus.bDriveEnabled       := nModbusReadBlk1[11].0;	
stSpindleStatus.nDCBusVoltage		:= INT_TO_UINT(nModbusReadBlk1[23]); 
stSpindleStatus.nDrivePowerStageTemp:= nModbusReadBlk1[24];	
stSpindleStatus.nRelayOutputStatus  := INT_TO_WORD(nModbusReadBlk1[29]);  
stSpindleStatus.nKWHourMeter        := INT_TO_UINT(nModbusReadBlk1[32]);  
stSpindleStatus.nRuntimeHours       := INT_TO_UINT(nModbusReadBlk1[34]);  
stSpindleStatus.nRuntimeMinutes     := INT_TO_UINT(nModbusReadBlk1[35]);
stSpindleStatus.nInternalDriveTemp  := nModbusReadBlk1[39];
stSpindleStatus.nOutputVoltage      := INT_TO_UINT(nModbusReadBlk1[43]);

// Map Spindle Parameters

stSpindleParams.nMaxSpeedLimit		:= INT_TO_UINT(nModbusReadBlk2[129]);
stSpindleParams.nMinSpeedLimit	    := INT_TO_UINT(nModbusReadBlk2[130]);
stSpindleParams.nAccelRampTime		:= INT_TO_UINT(nModbusReadBlk2[131]);
stSpindleParams.nDecelRampTime		:= INT_TO_UINT(nModbusReadBlk2[132]);
stSpindleParams.nStopMode			:= INT_TO_UINT(nModbusReadBlk2[133]);
stSpindleParams.nMotorRatedVoltage	:= INT_TO_UINT(nModbusReadBlk2[135]);
stSpindleParams.nMotorRatedCurrent  := INT_TO_UINT(nModbusReadBlk2[136]);
stSpindleParams.nMotorRatedFrequency:= INT_TO_UINT(nModbusReadBlk2[137]);
stSpindleParams.nMotorRatedSpeed    := INT_TO_UINT(nModbusReadBlk2[138]);
stSpindleParams.nApplicationMode    := INT_TO_UINT(nModbusReadBlk2[141]);
stSpindleParams.nRelayOutputFunction:= INT_TO_UINT(nModbusReadBlk2[146]);
stSpindleParams.nUserPGain          := INT_TO_UINT(nModbusReadBlk2[169]);
stSpindleParams.nUserIConstant      := INT_TO_UINT(nModbusReadBlk2[170]);
stSpindleParams.nMotorControlMode   := INT_TO_UINT(nModbusReadBlk2[179]);
stSpindleParams.nMaximumCurrentLimit:= INT_TO_UINT(nModbusReadBlk2[182]);

IF bManualSpindleOverride THEN  
    nSpindleSetpoint    := nManualSpindleSetpoint;   
ELSE
    nSpindleSetpoint    := nSpindleSpeedFromNC;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_OutputMapping" Id="{9f934105-dd30-493a-85e5-9cee50265608}">
      <Declaration><![CDATA[METHOD M_OutputMapping : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map Spindle Control

stSpeedRefScaleParams.fInMax:= 24000.0 ;
stSpeedRefScaleParams.fInMin:=  8000.0;
stSpeedRefScaleParams.fOutMax:=  4000.0;
stSpeedRefScaleParams.fOutMin:=  1333.0;
stSpeedRefScaleParams.tCtrlCycleTime:= T#2MS  ;
stSpeedRefScaleParams.tTaskCycleTime:=  T#2MS ;

// Scale Spindle Speed Setpoint From RPM to Hz
fbSpeedRefScale(
                fIn:=nSpindleSetpoint,
                fOut=>fScaledSpindleSpeedRef,
                eErrorId=>,
                bError=>,
                stParams:=stSpeedRefScaleParams,
                                                    );                                                                                                 
                                                    
nModbusWriteDriveCommand.0 :=stSpindleControl.bRunEnable;
nModbusWriteDriveCommand.1 :=stSpindleControl.bFastStopReq;
nModbusWriteDriveCommand.2 :=stSpindleControl.bResetReq;
nModbusWriteDriveCommand.3 :=stSpindleControl.bCoastStopRequest;

nModbusWriteDriveSetpoint  :=LREAL_TO_INT(fScaledSpindleSpeedRef);

nModbusWriteDriveAccel_Decel :=stSpindleControl.nRampControlTime;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ReadParameters" Id="{a233cd63-eba1-4191-8645-5e9df383ad75}">
      <Declaration><![CDATA[METHOD M_ReadParameters : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bResetSerialComm THEN
    eReadVFDParamsSeq := FINISH;    
END_IF
    CASE eReadVFDParamsSeq OF
        
        INIT_FIRST:
            fbModbusMasterEL.ReadRegs(Execute:=bReadExecute);
            eReadVFDParamsSeq:=READ_FIRST_BLOCK;
        
        READ_FIRST_BLOCK:
            bReadExecute:=TRUE;
            fbModbusMasterEL.ReadRegs(
                                    UnitID:= 1, 
                                    Quantity:= 45, 
                                    MBAddr:= 0, 
                                    cbLength:= SIZEOF(nModbusReadBlk1), 
                                    pMemoryAddr:= ADR(nModbusReadBlk1), 
                                    Execute:= bReadExecute, 
                                    Timeout:= T#300MS, 
                                    Busy=> bReadBusy, 
                                    Error=> bReadError, 
                                    ErrorId=> eReadErrorID, 
                                    cbRead=> nCbRead);
									
			 trigReadBusy(CLK:=bReadBusy);						
             IF trigReadBusy.Q AND NOT bReadError THEN
             	bReadExecute:=FALSE;                       
             	eReadVFDParamsSeq:=INIT_SECOND;
             END_IF 
             
        INIT_SECOND:
		
           fbModbusMasterEL.ReadRegs(Execute:=bReadExecute);
           eReadVFDParamsSeq:=READ_SECOND_BLOCK; 
    
        READ_SECOND_BLOCK:
            bReadExecute:=TRUE;
            fbModbusMasterEL.ReadRegs(
                                    UnitID:= 1, 
                                    Quantity:= 59, 
                                    MBAddr:= 128, 
                                    cbLength:= SIZEOF(nModbusReadBlk2), 
                                    pMemoryAddr:= ADR(nModbusReadBlk2), 
                                    Execute:= bReadExecute, 
                                    Timeout:= T#300MS, 
                                    Busy=> bReadBusy, 
                                    Error=> bReadError, 
                                    ErrorId=> eReadErrorID, 
                                    cbRead=> nCbRead);
                                    
             trigReadBusy(CLK:=bReadBusy);						
             IF trigReadBusy.Q AND NOT bReadError THEN                       
             	eReadVFDParamsSeq:=FINISH;
             END_IF 
        
        FINISH:
        bReadExecute:=FALSE;     
        eReadVFDParamsSeq:=INIT_FIRST;
    
    END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ResetDriveError" Id="{6a769b7b-415c-4e9d-90e8-e0d6e861e949}">
      <Declaration><![CDATA[METHOD M_ResetDriveError : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SetSpeed" Id="{0d91e475-0382-4cfa-b413-5ce8843a481a}">
      <Declaration><![CDATA[METHOD M_SetSpeed : BOOL
VAR_INPUT
    bExecute    : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ 
CASE eSetSpindleSpeedSeq OF
    
START:
    M_SetSpeed:=FALSE;
    bSpindleAtRequestedSpeed := FALSE;
    bWriteDriveSetpoint := FALSE;
    bWriteAccel_Decel := FALSE;
    IF stSpindleStatus.bDriveReady AND stSpindleStatus.bDriveEnabled AND bExecute THEN
        eSetSpindleSpeedSeq:=SET_ACCEL;
	END_IF
    
SET_ACCEL:
    bWriteAccel_Decel:=TRUE;
    fbModbusMasterEL.WriteSingleRegister(   
                                          UnitID:=1,
                                          Quantity:=1,
                                          MBAddr:=3,
                                          cbLength:=SIZEOF(nModbusWriteDriveAccel_Decel),
                                          pMemoryAddr:=ADR(nModbusWriteDriveAccel_Decel),
                                          Execute:=bWriteAccel_Decel,
                                          Timeout:=T#400MS,
                                          Busy => bWriteBusy);      
	trigWriteBusy(CLK := bWriteBusy); 
    IF trigWriteBusy.Q THEN
		bWriteAccel_Decel := FALSE;
        eSetSpindleSpeedSeq:=SET_SPEED;
    END_IF
                                                    
SET_SPEED:
    bWriteDriveSetpoint:=TRUE;
    fbModbusMasterEL.WriteSingleRegister(   
                                                  UnitID:=1,
                                                  Quantity:=1,
                                                  MBAddr:=1,
                                                  cbLength:=SIZEOF(nModbusWriteDriveSetpoint),
                                                  pMemoryAddr:=ADR(nModbusWriteDriveSetpoint),
                                                  Execute:=bWriteDriveSetpoint,
                                                  Timeout:=T#400MS,
                                                  Busy => bWriteBusy);      
	trigWriteBusy(CLK := bWriteBusy); 
    IF trigWriteBusy.Q THEN
		bWriteDriveSetpoint := FALSE;
        eSetSpindleSpeedSeq:=FINISH_SPEED;
    END_IF

FINISH_SPEED:
          fbMessage.CreateEx(TC_Events.CNC_Events.Spindle_Speed_Updated,0); 
          fbMessage.Send(0);
          bWriteDriveSetpoint := FALSE;
          bWriteAccel_Decel := FALSE; 
          eSetSpindleSpeedSeq:=START_ENABLE;

START_ENABLE:

    stSpindleControl.bRunEnable := FALSE;
    stSpindleControl.bResetReq  := FALSE;
    IF NOT stSpindleControl.bRunEnable AND NOT stSpindleControl.bResetReq THEN
        eSetSpindleSpeedSeq:=ENABLE_DRIVE;
	END_IF 
    
ENABLE_DRIVE:

    stSpindleControl.bRunEnable := TRUE;
    fbModbusMasterEL.WriteSingleRegister(   
                                          UnitID:=1,
                                          Quantity:=1,
                                          MBAddr:=0,
                                          cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                          pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                          Execute:=stSpindleControl.bRunEnable,
                                          Timeout:=T#400MS,
										  Busy => bWriteBusy);
	 trigWriteBusy(CLK := bWriteBusy); 
     IF trigWriteBusy.Q THEN
		stSpindleControl.bRunEnable := FALSE; 
        eSetSpindleSpeedSeq:=FINISH_ENABLE; 
     END_IF 
(*                                                    
RESET_DRIVE:
    bWriteTimerExec := TRUE;
    stSpindleControl.bRunEnable:= TRUE;
    stSpindleControl.bResetReq := TRUE;

    fbModbusMasterEL.WriteSingleRegister(   
                                                                UnitID:=1,
                                                                Quantity:=1,
                                                                MBAddr:=0,
                                                                cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                                                pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                                                Execute:=TRUE,
                                                                Timeout:=T#400MS, );
     IF stSpindleControl.bRunEnable AND stSpindleControl.bResetReq AND tWriteTimer.Q THEN 
          eSetSpindleSpeedSeq:=FINISH_ENABLE;
     END_IF 
*)
FINISH_ENABLE:
 
	IF stSpindleStatus.bDriveRunning AND stSpindleStatus.nSpeedRefSetpoint = nModbusWriteDriveSetpoint THEN
		bSpindleAtRequestedSpeed := TRUE;
    	M_SetSpeed:=TRUE;
    	bExecute := FALSE;
		eSetSpindleSpeedSeq :=START;
		fbMessage.CreateEx(TC_Events.CNC_Events.Spindle_Active,0); 
    	fbMessage.Send(0);
	END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SpindleTesting" Id="{27b70598-57d2-4a29-8336-ceb84a506860}">
      <Declaration><![CDATA[METHOD M_SpindleTesting : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbModbusMasterEL.WriteSingleRegister(   
                                            UnitID:=1,
                                            Quantity:=1,
                                            MBAddr:=0,
                                            cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                            pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                            Execute:=bTestEnable,
                                            Timeout:=T#400MS, );
                                                           
fbModbusMasterEL.WriteSingleRegister(   
                                             UnitID:=1,
                                             Quantity:=1,
                                             MBAddr:=3,
                                             cbLength:=SIZEOF(nModbusWriteDriveAccel_Decel),
                                             pMemoryAddr:=ADR(nModbusWriteDriveAccel_Decel),
                                             Execute:=bTestAccel,
                                             Timeout:=T#400MS,
                                             Busy => bWriteBusy );

fbModbusMasterEL.WriteSingleRegister(   
                                              UnitID:=1,
                                              Quantity:=1,
                                              MBAddr:=1,
                                              cbLength:=SIZEOF(nModbusWriteDriveSetpoint),
                                              pMemoryAddr:=ADR(nModbusWriteDriveSetpoint),
                                              Execute:=bTestSetSpeed,
                                              Timeout:=T#400MS,
                                              Busy => bWriteBusy );                                                            ]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SpindleFunctions">
      <LineId Id="2312" Count="3" />
      <LineId Id="2317" Count="1" />
      <LineId Id="2560" Count="0" />
      <LineId Id="2323" Count="2" />
      <LineId Id="2639" Count="4" />
      <LineId Id="2645" Count="3" />
      <LineId Id="2650" Count="3" />
      <LineId Id="1542" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_ActiveSpeedChange">
      <LineId Id="6" Count="0" />
      <LineId Id="9" Count="8" />
      <LineId Id="21" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_CoastStop">
      <LineId Id="64" Count="2" />
      <LineId Id="10" Count="10" />
      <LineId Id="114" Count="0" />
      <LineId Id="22" Count="7" />
      <LineId Id="120" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="109" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="106" Count="1" />
      <LineId Id="105" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="87" Count="2" />
      <LineId Id="115" Count="0" />
      <LineId Id="91" Count="7" />
      <LineId Id="124" Count="2" />
      <LineId Id="100" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="54" Count="1" />
      <LineId Id="57" Count="1" />
      <LineId Id="60" Count="3" />
      <LineId Id="5" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="67" Count="1" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_DriveErrors">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_Enable">
      <LineId Id="5" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="42" Count="2" />
      <LineId Id="37" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="24" Count="7" />
      <LineId Id="23" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="51" Count="8" />
      <LineId Id="41" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="66" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="72" Count="1" />
      <LineId Id="65" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_FastStop">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_HMI_In">
      <LineId Id="6" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="11" Count="5" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_HMI_Out">
      <LineId Id="26" Count="0" />
      <LineId Id="4" Count="20" />
      <LineId Id="50" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="47" Count="2" />
      <LineId Id="55" Count="10" />
      <LineId Id="69" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="85" Count="16" />
      <LineId Id="84" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="80" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_InitalizeParameters">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_InputMapping">
      <LineId Id="39" Count="0" />
      <LineId Id="6" Count="2" />
      <LineId Id="78" Count="2" />
      <LineId Id="77" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="4" />
      <LineId Id="81" Count="0" />
      <LineId Id="67" Count="7" />
      <LineId Id="86" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="100" Count="12" />
      <LineId Id="117" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="119" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_OutputMapping">
      <LineId Id="5" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="4" />
      <LineId Id="43" Count="0" />
      <LineId Id="25" Count="6" />
      <LineId Id="24" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="8" Count="3" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_ReadParameters">
      <LineId Id="87" Count="0" />
      <LineId Id="149" Count="1" />
      <LineId Id="88" Count="3" />
      <LineId Id="93" Count="2" />
      <LineId Id="144" Count="0" />
      <LineId Id="97" Count="11" />
      <LineId Id="156" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="109" Count="5" />
      <LineId Id="154" Count="0" />
      <LineId Id="116" Count="3" />
      <LineId Id="145" Count="0" />
      <LineId Id="121" Count="13" />
      <LineId Id="157" Count="0" />
      <LineId Id="135" Count="3" />
      <LineId Id="140" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_ResetDriveError">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_SetSpeed">
      <LineId Id="140" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="191" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="172" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="176" Count="10" />
      <LineId Id="280" Count="0" />
      <LineId Id="267" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="166" Count="0" />
      <LineId Id="154" Count="7" />
      <LineId Id="128" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="162" Count="1" />
      <LineId Id="53" Count="1" />
      <LineId Id="167" Count="1" />
      <LineId Id="91" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="197" Count="0" />
      <LineId Id="203" Count="8" />
      <LineId Id="285" Count="0" />
      <LineId Id="213" Count="0" />
      <LineId Id="215" Count="7" />
      <LineId Id="271" Count="0" />
      <LineId Id="282" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="274" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="227" Count="19" />
      <LineId Id="250" Count="0" />
      <LineId Id="275" Count="0" />
      <LineId Id="283" Count="0" />
      <LineId Id="253" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="277" Count="2" />
      <LineId Id="276" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_SpindleTesting">
      <LineId Id="6" Count="6" />
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="15" Count="7" />
      <LineId Id="14" Count="0" />
      <LineId Id="24" Count="8" />
      <LineId Id="23" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>