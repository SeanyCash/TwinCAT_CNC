<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_SpindleFunctions" Id="{d33eb993-f1a5-484e-9d4d-ae7861108719}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SpindleFunctions IMPLEMENTS I_HMI;

// Spindle VFD control for Invertek Optidrive E3 (240V single phase input, 240V three phase output, 2.2KW) and GMT 400hz 2.2kw 3 HP Spindle using Modbus RTU

VAR
    
 fbModbusMasterEL   : ModbusRtuMasterV2_KL6x22B;
 fbSpeedRefScale    : FB_CTRL_SCALE;
 fbMessage		    : FB_TcMessage;
 stSpeedRefScaleParams            : ST_CTRL_SCALE_PARAMS;
 fScaledSpindleSpeedRef    : LREAL;
 nModbusReadBlk1    : ARRAY [1..46] OF INT;
 nModbusReadBlk2    : ARRAY [129..188] OF INT;
 // Need to put into a modbus DUT
 nModbusID          : BYTE :=1;
 nModbusReadQty     : WORD :=24;
 nModbusReadAddr    : WORD;
 tReadTimer         : TON;
 bReadTimerExecute  : BOOL;
 bReadExecute       : BOOL;
 bDiagExecute       : BOOL;
 eReadErrorID       : MODBUS_ERRORS;
 nCbRead            : UINT;
 bReadBusy          : BOOL;
 bReadError         : BOOL;
 bWriteBusy         : BOOL;
 bWriteError        : BOOL;
 nCbWrite           : UINT;
 
 bWriteDriveCommand             : BOOL;
 bWriteDriveSetpoint            : BOOL;
 bWriteAccel_Decel              : BOOL;
 nModbusWriteDriveCommand       : WORD;
 nModbusWriteDriveSetpoint      : INT;
 nModbusWriteDriveAccel_Decel   : UINT;
 
 
 eVFDErrors         : E_VFDErrors;
 stSpindleStatus	: ST_SpindleStatus;
 stSpindleParams    : ST_SpindleParameters;
 stSpindleControl   : ST_SpindleControl;

// Read Parameters Sequence Enumeration
 eReadVFDParamsSeq  :(INIT_FIRST,READ_FIRST_BLOCK,INIT_SECOND,READ_SECOND_BLOCK,FINISH);
 eWriteVFDParamsSeq :(INIT,WRITE_DRIVE_COMMAND,WRITE_SPINDLE_SPEED,WRITE_ACCEL_DECEL);

END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[M_ReadParameters();
M_InputMapping();
M_OutputMapping();
M_DriveErrors();
M_WriteParameters();
M_HMI_In();
M_HMI_Out();

tReadTimer(IN:=bReadTimerExecute,PT:=T#500MS,);


                                       
]]></ST>
    </Implementation>
    <Method Name="M_DriveErrors" Id="{5214dc49-55b0-4763-8ae7-946b59ed4930}">
      <Declaration><![CDATA[METHOD M_DriveErrors : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[eVFDErrors:= stSpindleStatus.nErrorCode;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_HMI_In" Id="{7023150e-5dba-40bd-b6bf-f2224d2f965b}">
      <Declaration><![CDATA[METHOD M_HMI_In : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_HMI_Out" Id="{7a175b83-8eaa-4aad-b855-25562de10eb8}">
      <Declaration><![CDATA[
METHOD M_HMI_Out : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map VFD status information to HMI struct

stHMI_Out.nSpeedRefSetpoint	    :=    stSpindleStatus.nSpeedRefSetpoint;	  
stHMI_Out.nRampControlTime      :=    stSpindleStatus.nRampControlTime;    
stHMI_Out.sErrorCode		    :=    TO_STRING(eVFDErrors);	 
stHMI_Out.bDriveRunning         :=    stSpindleStatus.bDriveRunning; 
stHMI_Out.bDriveFault           :=    stSpindleStatus.bDriveFault;   
stHMI_Out.bStandbyMode          :=    stSpindleStatus.bStandbyMode;  
stHMI_Out.bDriveReady           :=    stSpindleStatus.bDriveReady;   
stHMI_Out.nOutputFreq		    :=    stSpindleStatus.nOutputFreq;	 
stHMI_Out.nMotorCurrent		    :=    stSpindleStatus.nMotorCurrent;
stHMI_Out.nMotorTorque          :=    stSpindleStatus.nMotorTorque; 
stHMI_Out.nMotorPower           :=    stSpindleStatus.nMotorPower;  
stHMI_Out.bDigitalInput1  	    :=    stSpindleStatus.nDigitalInputSts.0;
stHMI_Out.bDigitalInput2  	    :=    stSpindleStatus.nDigitalInputSts.1;
stHMI_Out.bDigitalInput3  	    :=    stSpindleStatus.nDigitalInputSts.2;    
stHMI_Out.bDigitalInput4  	    :=    stSpindleStatus.nDigitalInputSts.3;
stHMI_Out.bDriveEnabled         :=    stSpindleStatus.bDriveEnabled;       
stHMI_Out.nDCBusVoltage		    :=    stSpindleStatus.nDCBusVoltage;		     
stHMI_Out.nDrivePowerStageTemp  :=    stSpindleStatus.nDrivePowerStageTemp;
stHMI_Out.bRelayOutputStatus    :=    stSpindleStatus.nRelayOutputStatus.0;   
stHMI_Out.nKWHourMeter          :=    stSpindleStatus.nKWHourMeter;  
stHMI_Out.nRuntimeHours         :=    stSpindleStatus.nRuntimeHours;
stHMI_Out.nRuntimeMinutes       :=    stSpindleStatus.nRuntimeMinutes;
stHMI_Out.nInternalDriveTemp    :=    stSpindleStatus.nInternalDriveTemp;  
stHMI_Out.nOutputVoltage        :=    stSpindleStatus.nOutputVoltage;

    
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_InputMapping" Id="{83d865f8-d7ae-49d7-a6f4-fcb7ec40a615}">
      <Declaration><![CDATA[METHOD M_InputMapping : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map Spindle Status
stSpindleStatus.nControlWord        := INT_TO_WORD(nModbusReadBlk1[1]);	   
stSpindleStatus.nSpeedRefSetpoint	:= nModbusReadBlk1[2];
stSpindleStatus.nRampControlTime    := INT_TO_UINT(nModbusReadBlk1[4]);
stSpindleStatus.bDriveRunning       := nModbusReadBlk1[6].0;
stSpindleStatus.bDriveFault         := nModbusReadBlk1[6].1;
stSpindleStatus.bStandbyMode        := nModbusReadBlk1[6].5;
stSpindleStatus.bDriveReady         := nModbusReadBlk1[6].6;                                  
stSpindleStatus.nErrorCode			:= INT_TO_BYTE(SHR(nModbusReadBlk1[6],8)); 
stSpindleStatus.nOutputFreq			:= nModbusReadBlk1[7];	
stSpindleStatus.nMotorCurrent		:= INT_TO_UINT(nModbusReadBlk1[8]);  
stSpindleStatus.nMotorTorque        := nModbusReadBlk1[9];  
stSpindleStatus.nMotorPower         := INT_TO_UINT(nModbusReadBlk1[10]);  
stSpindleStatus.nDigitalInputSts	:= INT_TO_WORD(nModbusReadBlk1[11]);
stSpindleStatus.bDriveEnabled       := nModbusReadBlk1[11].0;	
stSpindleStatus.nDCBusVoltage		:= INT_TO_UINT(nModbusReadBlk1[23]); 
stSpindleStatus.nDrivePowerStageTemp:= nModbusReadBlk1[24];	
stSpindleStatus.nRelayOutputStatus  := INT_TO_WORD(nModbusReadBlk1[29]);  
stSpindleStatus.nKWHourMeter        := INT_TO_UINT(nModbusReadBlk1[32]);  
stSpindleStatus.nRuntimeHours       := INT_TO_UINT(nModbusReadBlk1[34]);  
stSpindleStatus.nRuntimeMinutes     := INT_TO_UINT(nModbusReadBlk1[35]);
stSpindleStatus.nInternalDriveTemp  := nModbusReadBlk1[39];
stSpindleStatus.nOutputVoltage      := INT_TO_UINT(nModbusReadBlk1[43]);

// Map Spindle Parameters

stSpindleParams.nMaxSpeedLimit		:= INT_TO_UINT(nModbusReadBlk2[129]);
stSpindleParams.nMinSpeedLimit	    := INT_TO_UINT(nModbusReadBlk2[130]);
stSpindleParams.nAccelRampTime		:= INT_TO_UINT(nModbusReadBlk2[131]);
stSpindleParams.nDecelRampTime		:= INT_TO_UINT(nModbusReadBlk2[132]);
stSpindleParams.nStopMode			:= INT_TO_UINT(nModbusReadBlk2[133]);
stSpindleParams.nMotorRatedVoltage	:= INT_TO_UINT(nModbusReadBlk2[135]);
stSpindleParams.nMotorRatedCurrent  := INT_TO_UINT(nModbusReadBlk2[136]);
stSpindleParams.nMotorRatedFrequency:= INT_TO_UINT(nModbusReadBlk2[137]);
stSpindleParams.nMotorRatedSpeed    := INT_TO_UINT(nModbusReadBlk2[138]);
stSpindleParams.nApplicationMode    := INT_TO_UINT(nModbusReadBlk2[141]);
stSpindleParams.nRelayOutputFunction:= INT_TO_UINT(nModbusReadBlk2[146]);
stSpindleParams.nUserPGain          := INT_TO_UINT(nModbusReadBlk2[169]);
stSpindleParams.nUserIConstant      := INT_TO_UINT(nModbusReadBlk2[170]);
stSpindleParams.nMotorControlMode   := INT_TO_UINT(nModbusReadBlk2[179]);
stSpindleParams.nMaximumCurrentLimit:= INT_TO_UINT(nModbusReadBlk2[182]);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_OutputMapping" Id="{9f934105-dd30-493a-85e5-9cee50265608}">
      <Declaration><![CDATA[METHOD M_OutputMapping : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Map Spindle Control

stSpeedRefScaleParams.fInMax:= 24000.0 ;
stSpeedRefScaleParams.fInMin:=  0.0;
stSpeedRefScaleParams.fOutMax:=  4000.0;
stSpeedRefScaleParams.fOutMin:=  0.0;
stSpeedRefScaleParams.tCtrlCycleTime:= T#2MS  ;
stSpeedRefScaleParams.tTaskCycleTime:=  T#2MS ;

// Scale Spindle Speed Setpoint From RPM to Hz
fbSpeedRefScale(
                fIn:=stSpindleControl.i_nSpindleRPMFromNC,
                fOut=>fScaledSpindleSpeedRef,
                eErrorId=>,
                bError=>,
                stParams:=stSpeedRefScaleParams,
                                                    );
                                                    
nModbusWriteDriveCommand.0 :=stSpindleControl.bRunEnable;
nModbusWriteDriveCommand.1 :=stSpindleControl.bFastStopReq;
nModbusWriteDriveCommand.2 :=stSpindleControl.bResetReq;
nModbusWriteDriveCommand.3 :=stSpindleControl.bCoastStopRequest;

nModbusWriteDriveSetpoint  :=LREAL_TO_INT(fScaledSpindleSpeedRef);

nModbusWriteDriveAccel_Decel :=stSpindleControl.nRampControlTime;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ReadParameters" Id="{a233cd63-eba1-4191-8645-5e9df383ad75}">
      <Declaration><![CDATA[METHOD M_ReadParameters : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
    CASE eReadVFDParamsSeq OF
        
        INIT_FIRST:
            fbModbusMasterEL.ReadRegs(Execute:=bReadExecute);
            bReadTimerExecute:=FALSE;
            eReadVFDParamsSeq:=READ_FIRST_BLOCK;
        
        READ_FIRST_BLOCK:
            bReadExecute:=TRUE;
            bReadTimerExecute:=TRUE;
            fbModbusMasterEL.ReadRegs(
                                    UnitID:= 1, 
                                    Quantity:= 45, 
                                    MBAddr:= 0, 
                                    cbLength:= SIZEOF(nModbusReadBlk1), 
                                    pMemoryAddr:= ADR(nModbusReadBlk1), 
                                    Execute:= bReadExecute, 
                                    Timeout:= T#400MS, 
                                    Busy=> bReadBusy, 
                                    Error=> bReadError, 
                                    ErrorId=> eReadErrorID, 
                                    cbRead=> nCbRead);
             IF tReadTimer.Q AND NOT bReadError THEN
             bReadExecute:=FALSE;                       
             eReadVFDParamsSeq:=INIT_SECOND;
             END_IF 
             
        INIT_SECOND:
           bReadTimerExecute:=FALSE;
           fbModbusMasterEL.ReadRegs(Execute:=bReadExecute);
           eReadVFDParamsSeq:=READ_SECOND_BLOCK; 
    
        READ_SECOND_BLOCK:
            bReadExecute:=TRUE;
            bReadTimerExecute:=TRUE; 
            fbModbusMasterEL.ReadRegs(
                                    UnitID:= 1, 
                                    Quantity:= 59, 
                                    MBAddr:= 128, 
                                    cbLength:= SIZEOF(nModbusReadBlk2), 
                                    pMemoryAddr:= ADR(nModbusReadBlk2), 
                                    Execute:= bReadExecute, 
                                    Timeout:= T#400MS, 
                                    Busy=> bReadBusy, 
                                    Error=> bReadError, 
                                    ErrorId=> eReadErrorID, 
                                    cbRead=> nCbRead);
                                    
             IF tReadTimer.Q AND NOT bReadError THEN                       
             eReadVFDParamsSeq:=FINISH;
             END_IF 
        
        FINISH:
        bReadTimerExecute:=FALSE;
        bReadExecute:=FALSE;     
        eReadVFDParamsSeq:=INIT_FIRST;
    
    END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_WriteParameters" Id="{2cc1a04a-a448-4214-8312-bc9179b7e0fd}">
      <Declaration><![CDATA[METHOD M_WriteParameters : BOOL

VAR
    
    bWriteTrigger : R_TRIG;

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*(*Ctrl bits - individual bits from iCtrl*)
	bTransmitRequest		: BOOL; // A change of this bit acts as a request to send data
	bReceiveAccepted		: BOOL; // A change of this bit acts as a request for more data
	bInitRequest			: BOOL; // low -> high is a request for serial module init
	bSendContinuous			: BOOL; // not used
	nOutputLength			: BYTE; 
	
	(*Status bits - individual bits from iStatus*)
	bTransmitAccepted		: BOOL; //a change of this bit acts as a confirmation of bTransmitRequest
	bReceiveRequest			: BOOL; // a change of this bit acts as a confirmation of bReceiveAccepted
	bInitAccepted			: BOOL; // low-> high is confirmation of serial module init
	bBufferFull				: BOOL; // serial module buffer is full
	bParityError			: BOOL; 
	bFramingError			: BOOL;
	bOverrunError			: BOOL;
	nInputLength			: BYTE;



*)

CASE eWriteVFDParamsSeq OF


    INIT:
    
        bWriteDriveCommand := FALSE;
        bWriteDriveSetpoint := FALSE;
        bWriteAccel_Decel := FALSE;
        
  

    WRITE_DRIVE_COMMAND:     
        bWriteDriveCommand:=TRUE;                                         
        fbModbusMasterEL.WriteSingleRegister(   
                                            UnitID:=1,
                                            Quantity:=1,
                                            MBAddr:=0,
                                            cbLength:=SIZEOF(nModbusWriteDriveCommand),
                                            pMemoryAddr:=ADR(nModbusWriteDriveCommand),
                                            Execute:=bWriteDriveCommand,
                                            Timeout:=T#400MS,
                                                                    );   
            
    WRITE_SPINDLE_SPEED:
        
        fbModbusMasterEL.WriteSingleRegister(   
                                                            UnitID:=1,
                                                            Quantity:=1,
                                                            MBAddr:=1,
                                                            cbLength:=SIZEOF(nModbusWriteDriveSetpoint),
                                                            pMemoryAddr:=ADR(nModbusWriteDriveSetpoint),
                                                            Execute:=bWriteDriveSetpoint,
                                                            Timeout:=T#400MS, );

    WRITE_ACCEL_DECEL:
       bWriteAccel_Decel:=TRUE;                                                  
       fbModbusMasterEL.WriteSingleRegister(   
                                           UnitID:=1,
                                           Quantity:=1,
                                           MBAddr:=3,
                                           cbLength:=SIZEOF(nModbusWriteDriveAccel_Decel),
                                           pMemoryAddr:=ADR(nModbusWriteDriveAccel_Decel),
                                           Execute:=bWriteAccel_Decel,
                                           Timeout:=T#400MS,
                                                           );                                                       
                       

END_CASE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_SpindleFunctions">
      <LineId Id="2094" Count="0" />
      <LineId Id="2028" Count="0" />
      <LineId Id="2093" Count="0" />
      <LineId Id="2136" Count="0" />
      <LineId Id="2096" Count="0" />
      <LineId Id="2180" Count="1" />
      <LineId Id="2092" Count="0" />
      <LineId Id="2032" Count="0" />
      <LineId Id="2089" Count="2" />
      <LineId Id="1542" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_DriveErrors">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_HMI_In">
      <LineId Id="4" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_HMI_Out">
      <LineId Id="26" Count="1" />
      <LineId Id="4" Count="20" />
      <LineId Id="50" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="47" Count="2" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_InputMapping">
      <LineId Id="39" Count="0" />
      <LineId Id="6" Count="2" />
      <LineId Id="78" Count="2" />
      <LineId Id="77" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="4" />
      <LineId Id="81" Count="0" />
      <LineId Id="67" Count="7" />
      <LineId Id="86" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="100" Count="12" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_OutputMapping">
      <LineId Id="5" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="4" />
      <LineId Id="43" Count="0" />
      <LineId Id="25" Count="6" />
      <LineId Id="24" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="8" Count="3" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_ReadParameters">
      <LineId Id="87" Count="8" />
      <LineId Id="144" Count="0" />
      <LineId Id="96" Count="23" />
      <LineId Id="145" Count="0" />
      <LineId Id="120" Count="22" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SpindleFunctions.M_WriteParameters">
      <LineId Id="227" Count="14" />
      <LineId Id="221" Count="5" />
      <LineId Id="124" Count="0" />
      <LineId Id="130" Count="2" />
      <LineId Id="134" Count="1" />
      <LineId Id="179" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="87" Count="7" />
      <LineId Id="71" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="209" Count="0" />
      <LineId Id="214" Count="6" />
      <LineId Id="210" Count="0" />
      <LineId Id="200" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="42" Count="7" />
      <LineId Id="40" Count="0" />
      <LineId Id="160" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="126" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>